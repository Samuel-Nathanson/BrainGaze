import React, { Component } from 'react';
import webgazer from 'webgazer';
import AnimatedCalibrationPoint from './AnimatedCalibrationPoint';
import AnimatedTestPoint from './AnimatedTestPoint';

class CalibrationComponent extends Component {
  constructor(props) {
    super(props);
    this.state = {
      currentPointIndex: 0,
      calibrationComplete: false,
      webgazerInitialized: false,
      calibrationPoints: this.getInitializationPoints(),
      testing: true,
      recordedGazeLocations: [], // To store recorded gaze locations
      recordedPointLocations: [], // To store recorded point locations
      meanSquaredError: null, // To store the computed MSE
    };
    webgazer.showVideo(false);
    webgazer.showPredictionPoints(false);
    webgazer.clearData();
    webgazer.begin();
  }

  componentWillUnmount() {
    // webgazer.end();
  }

	getInitializationPoints() {
		const calibrationPoints = [
			{ x: '10%', y: '10%' }, // top-left
			{ x: '50%', y: '10%' }, // middle-top
			{ x: '90%', y: '10%' }, // top-right
			{ x: '10%', y: '50%' }, // middle-left
			{ x: '50%', y: '50%' },  // center
			{ x: '90%', y: '50%' }, // middle-right
			{ x: '10%', y: '90%' }, // bottom-left
			{ x: '50%', y: '90%' }, // middle-bottom
			{ x: '90%', y: '90%' } // bottom-right
			];

			return calibrationPoints;
  }

  componentDidMount() {
		setTimeout(() => {
			this.showPointsInterval = setInterval(() => {
				this.setState({ currentPointIndex: this.state.currentPointIndex+1 });
				if (this.state.currentPointIndex === this.state.calibrationPoints.length) {
					this.setState({calibrationComplete: true});
					clearInterval(this.showPointsInterval);
				}
			}, this.state.testing ? 100 : 4000);
		}, this.state.testing? 100 : 10000);
	}

  // Function to record gaze and point locations
  recordLocations = () => {
    const { calibrationPoints, currentPointIndex } = this.state;
    const currentPoint = calibrationPoints[currentPointIndex];
    const recordedGazeLocations = [...this.state.recordedGazeLocations];
    const recordedPointLocations = [...this.state.recordedPointLocations];

    // Simulate getting the predicted gaze location
    // Simulate getting the predicted gaze location
    const predictedGazeLocation = webgazer.getCurrentPrediction();

    console.log(predictedGazeLocation)

    recordedGazeLocations.push(predictedGazeLocation);
    recordedPointLocations.push(currentPoint);

    this.setState({
      recordedGazeLocations,
      recordedPointLocations,
    });
  };

  // Function to compute mean squared error
  computeMeanSquaredError = () => {
    const { recordedGazeLocations, recordedPointLocations } = this.state;
    let mse = 0;

    // Calculate the mean squared error
    for (let i = 0; i < recordedGazeLocations.length; i++) {
      const gazeLocation = recordedGazeLocations[i];
      const pointLocation = recordedPointLocations[i];
      const dx = gazeLocation.x - pointLocation.x;
      const dy = gazeLocation.y - pointLocation.y;
      mse += dx * dx + dy * dy;
    }

    mse /= recordedGazeLocations.length;

    this.setState({
      meanSquaredError: mse,
    });
  };

  // Function to run the calibrated test with intervals
  runCalibratedTest = () => {
    webgazer.showPredictionPoints(true);
    this.setState({ currentPointIndex: 0 });
    this.showPointsInterval = setInterval(() => {
      this.setState({ currentPointIndex: this.state.currentPointIndex + 1 });

      // Record gaze and point locations at the end of the interval
      this.recordLocations();

      if (this.state.currentPointIndex === this.state.calibrationPoints.length) {
        clearInterval(this.showPointsInterval);

        // All intervals are complete, compute MSE
        this.computeMeanSquaredError();
      }
    }, 4000); // Adjust the delay time as needed
  };

  componentDidUpdate(prevProps, prevState) {
    if (this.state.calibrationComplete && !prevState.calibrationComplete) {
      this.runCalibratedTest();
    }
  }

  render() {
    return (
      <div id='calibration-container' style={{ backgroundImage: this.state.calibrationComplete ? '' : '' }}>
        {this.state.calibrationPoints.map((point, index) => (
					this.state.calibrationComplete ? 
						<AnimatedTestPoint 
							x={point.x}
							y={point.y}
							visibility={(this.state.currentPointIndex === index && this.state.calibrationComplete) 
								? 'visible' : 'hidden'}
						/> :
						<AnimatedCalibrationPoint 
						x={point.x}
						y={point.y}
						visibility={(this.state.currentPointIndex === index && !this.state.calibrationComplete) 
							? 'visible' : 'hidden'}
					/> 
				))}
        <p>Recorded Gaze Locations: {JSON.stringify(this.state.recordedGazeLocations)}</p>
        <p>Recorded Point Locations: {JSON.stringify(this.state.recordedPointLocations)}</p>
        <p>Mean Squared Error (MSE): {this.state.meanSquaredError}</p>
      </div>
    );
  }
}

export default CalibrationComponent;
